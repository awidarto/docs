---
title: "XLSX Template Data Merge Commands"
description: "Merging json data with xlsx template"
---
For PDF conversion from XLSX, **PhpSpreadsheet** recommends using libraries like `mPDF` or `TCPDF` because they are better at handling the grid-like structure of a spreadsheet. We will use **mPDF**.

### Step 1: Install Additional Dependencies

You already have `phpoffice/phpspreadsheet`. Now, add the PDF rendering library.
```bash
composer require mpdf/mpdf
```
This is **only required** if you intend to use the `--mode=pdf` option.

### Step 2: The Final Command Code

Replace the entire content of `app/Console/Commands/XlsxGenerateCommand.php` with this updated code. It now includes the mode-switching logic.

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Arr;
use Illuminate\Support\Facades\File;
use PhpOffice\PhpSpreadsheet\IOFactory;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;

class XlsxGenerateCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'xlsx:generate
                            {--template=storage/app/templates/report_template.xlsx : The path to the XLSX template file}
                            {--output=storage/app/output/report : The base path for the generated file (extension is added automatically)}
                            {--data=report_data.json : The path to the JSON data file}
                            {--mode=merge : The output mode (merge, html, pdf)}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Generate XLSX, HTML, or PDF files from an XLSX template and a JSON data file.';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        $mode = $this->option('mode');
        $templatePath = $this->option('template');
        $outputPath = $this->option('output');
        $dataPath = $this->option('data');

        // 1. Validate inputs
        if (!in_array($mode, ['merge', 'html', 'pdf'])) {
            $this->error("Invalid mode '{$mode}'. Available modes are: merge, html, pdf.");
            return 1;
        }
        if (!File::exists($templatePath)) {
            $this->error("Template file not found at: {$templatePath}");
            return 1;
        }
        if (!File::exists($dataPath)) {
            $this->error("Data file not found at: {$dataPath}");
            return 1;
        }

        $finalOutputPath = $this->getFinalOutputPath($outputPath, $mode);
        File::ensureDirectoryExists(dirname($finalOutputPath));

        try {
            // 2. Process data and generate the spreadsheet object in memory
            $spreadsheet = $this->generateMergedSpreadsheet($templatePath, $dataPath);

            // 3. Save the spreadsheet in the requested format
            $this->saveSpreadsheet($spreadsheet, $finalOutputPath, $mode);

            $this->info(strtoupper($mode) . " file generated successfully at: {$finalOutputPath}");
            return 0;

        } catch (\Exception $e) {
            $this->error("An error occurred: " . $e->getMessage());
            return 1;
        }
    }

    /**
     * Loads template and data, performs the merge, and returns the Spreadsheet object.
     */
    private function generateMergedSpreadsheet(string $templatePath, string $dataPath): Spreadsheet
    {
        $data = json_decode(File::get($dataPath), true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \Exception("Invalid JSON in data file: " . json_last_error_msg());
        }

        $spreadsheet = IOFactory::load($templatePath);
        $worksheet = $spreadsheet->getActiveSheet();

        // Process loops first is crucial for correct row indexing
        $this->processLoops($worksheet, $data);

        // Process simple placeholders in all remaining cells
        $this->processPlaceholders($worksheet, $data);

        return $spreadsheet;
    }

    /**
     * Saves the final Spreadsheet object to a file in the specified format.
     */
    private function saveSpreadsheet(Spreadsheet $spreadsheet, string $path, string $mode)
    {
        $writer = null;
        switch($mode) {
            case 'merge':
                $writer = IOFactory::createWriter($spreadsheet, 'Xlsx');
                break;
            case 'html':
                $writer = IOFactory::createWriter($spreadsheet, 'Html');
                break;
            case 'pdf':
                if (!class_exists(\Mpdf\Mpdf::class)) {
                     $this->error('PDF generation requires mPDF. Please run: composer require mpdf/mpdf');
                     throw new \Exception('mPDF library not found.');
                }
                // This tells PhpSpreadsheet to use the mPDF library
                $writer = IOFactory::createWriter($spreadsheet, 'Mpdf');
                break;
        }
        $writer->save($path);
    }

    /**
     * Finds and processes all loop markers `${foreach:key}`.
     */
    private function processLoops(Worksheet $worksheet, array $data)
    {
        // This method's logic remains the same as before
        $loopMarkers = [];
        foreach ($worksheet->getRowIterator() as $row) {
            $cell = $worksheet->getCell('A' . $row->getRowIndex());
            $cellValue = $cell->getValue();
            if (is_string($cellValue) && preg_match('/^\${foreach:(.+)}$/', $cellValue, $matches)) {
                $loopMarkers[$row->getRowIndex()] = $matches[1];
            }
        }

        krsort($loopMarkers);

        foreach ($loopMarkers as $rowIndex => $dataKey) {
            $loopData = Arr::get($data, $dataKey, []);
            if (empty($loopData)) {
                $worksheet->removeRow($rowIndex);
                continue;
            }

            $numItems = count($loopData);
            if ($numItems > 1) {
                $worksheet->insertNewRowBefore($rowIndex + 1, $numItems - 1);
            }

            for ($i = 0; $i < $numItems; $i++) {
                $currentItem = $loopData[$i];
                $currentRowIndex = $rowIndex + $i;

                foreach ($worksheet->getColumnIterator() as $column) {
                    $columnIndex = $column->getColumnIndex();
                    $templateCell = $worksheet->getCell($columnIndex . $rowIndex);
                    $currentCell = $worksheet->getCell($columnIndex . $currentRowIndex);

                    if ($i > 0) {
                        $currentCell->setXfIndex($templateCell->getXfIndex());
                    }

                    $templateValue = $templateCell->getValue();
                    if (is_string($templateValue) && strpos($templateValue, '${') !== false) {
                        $newValue = preg_replace_callback('/\${item\.(.+?)}/', function ($matches) use ($currentItem) {
                            return Arr::get($currentItem, $matches[1], '');
                        }, $templateValue);

                        if (preg_match('/^\${foreach:.+}$/', $newValue)) {
                           $currentCell->setValue($i + 1);
                        } else {
                           $currentCell->setValue($newValue);
                        }
                    }
                }
            }
        }
    }

    /**
     * Finds and replaces simple `${key.name}` placeholders.
     */
    private function processPlaceholders(Worksheet $worksheet, array $data)
    {
        // This method's logic remains the same as before
        foreach ($worksheet->getRowIterator() as $row) {
            foreach ($row->getCellIterator() as $cell) {
                $cellValue = $cell->getValue();
                if (is_string($cellValue) && strpos($cellValue, '${') !== false) {
                    $newValue = preg_replace_callback('/\${(?!foreach:)(.+?)}/', function ($matches) use ($data) {
                        return Arr::get($data, $matches[1], '');
                    }, $cellValue);
                    if ($newValue !== $cellValue) {
                        $cell->setValue($newValue);
                    }
                }
            }
        }
    }

    /**
     * Determines the final output path with the correct extension.
     */
    private function getFinalOutputPath(string $basePath, string $mode): string
    {
        $extensionMap = [
            'merge' => '.xlsx',
            'html' => '.html',
            'pdf' => '.pdf',
        ];
        return $basePath . ($extensionMap[$mode] ?? '.xlsx');
    }
}

```

---

## English Documentation (Updated)

### **XLSX Universal Spreadsheet Generator Guide**

This guide explains how to use the `xlsx:generate` command to create `.xlsx`, `.html`, or `.pdf` files from a single XLSX template and a JSON data source.

#### **1. Setup and Installation**

1.  **Prerequisites**:
*   A working Laravel project.
*   Composer installed.
*   The `php-zip` PHP extension must be enabled.

2.  **Install PhpSpreadsheet**:
```bash
composer require phpoffice/phpspreadsheet
    ```
3.  **PDF Generation Prerequisite**:
To use the `pdf` mode, you must also install the **mPDF** rendering library.
```bash
composer require mpdf/mpdf
    ```

#### **2. Command Usage**

**Command Signature:**
```bash
php artisan xlsx:generate {--template=} {--output=} {--data=} {--mode=}
```

**Options:**
*   `--template`: Path to the input `.xlsx` template file.
*   `--output`: Base path for the output file. The correct extension (`.xlsx`, `.html`, `.pdf`) will be added automatically.
*   `--data`: Path to the JSON data file.
*   `--mode`: The operation mode. **Default**: `merge`.
*   `merge`: Merges JSON data into the template, creating a new `.xlsx` file.
*   `html`: Merges data and converts the result to a single `.html` file.
*   `pdf`: Merges data and converts the result to a `.pdf` file.

**Examples:**
```bash
# Default: Create a merged XLSX file
php artisan xlsx:generate

# Create an HTML preview of a report
php artisan xlsx:generate --output="reports/previews/oct_sales" --mode=html

# Create a final PDF version of a report
php artisan xlsx:generate --data="data/sales_final.json" --output="reports/final/oct_sales" --mode=pdf
```

#### **3. Template Tag Reference**

(This section remains the same as the previous documentation, explaining `${variable}` and the `${foreach:key}` / `${item.key}` syntax for loops.)

#### **4. Mode Explanations**

*   **`merge` (default)**: This is the standard operation. It takes your data and template and produces a fully functional `.xlsx` file, preserving all cell styles, formulas, and formatting.

*   **`html`**: This mode first merges the data and then converts the resulting spreadsheet into a single HTML file with an HTML table. It's excellent for embedding in web pages or for quick browser previews. All cell styling (colors, borders) is converted to inline CSS.

*   **`pdf`**: This mode performs the data merge and then uses the **mPDF** rendering engine to convert the spreadsheet to a PDF. This is ideal for generating printable reports.
*   **Requirement**: You must run `composer require mpdf/mpdf` first.
*   **Note**: The conversion works best for standard report layouts. Extremely wide spreadsheets may be scaled to fit the page, which could affect readability.

---

## Dokumentasi Bahasa Indonesia (Diperbarui)

### **Panduan Generator Spreadsheet Universal XLSX**

Panduan ini menjelaskan cara menggunakan perintah `xlsx:generate` untuk membuat file `.xlsx`, `.html`, atau `.pdf` dari satu templat XLSX dan sumber data JSON.

#### **1. Pengaturan dan Instalasi**

1.  **Prasyarat**:
*   Proyek Laravel yang sudah berjalan.
*   Composer sudah terinstal.
*   Ekstensi PHP `php-zip` harus diaktifkan.

2.  **Instal PhpSpreadsheet**:
```bash
composer require phpoffice/phpspreadsheet
    ```
3.  **Prasyarat Mode PDF**:
Untuk menggunakan mode `pdf`, Anda juga harus menginstal library rendering **mPDF**.
```bash
composer require mpdf/mpdf
    ```

#### **2. Penggunaan Perintah**

**Struktur Perintah:**
```bash
php artisan xlsx:generate {--template=} {--output=} {--data=} {--mode=}
```

**Opsi:**
*   `--template`: Path ke file templat `.xlsx` input.
*   `--output`: Path dasar untuk file output. Ekstensi yang benar (`.xlsx`, `.html`, `.pdf`) akan ditambahkan secara otomatis.
*   `--data`: Path ke file data JSON.
*   `--mode`: Mode operasi. **Default**: `merge`.
*   `merge`: Menggabungkan data JSON ke templat, menghasilkan file `.xlsx` baru.
*   `html`: Menggabungkan data dan mengonversi hasilnya menjadi satu file `.html`.
*   `pdf`: Menggabungkan data dan mengonversi hasilnya menjadi file `.pdf`.

**Contoh:**
```bash
# Default: Membuat file XLSX yang sudah digabung
php artisan xlsx:generate

# Membuat pratinjau HTML dari sebuah laporan
php artisan xlsx:generate --output="laporan/pratinjau/penjualan_okt" --mode=html

# Membuat versi PDF final dari sebuah laporan
php artisan xlsx:generate --data="data/penjualan_final.json" --output="laporan/final/penjualan_okt" --mode=pdf
```

#### **3. Referensi Tag Templat**

(Bagian ini tetap sama seperti dokumentasi sebelumnya, menjelaskan sintaks `${variabel}` dan `${foreach:key}` / `${item.key}` untuk perulangan.)

#### **4. Penjelasan Mode**

*   **`merge` (default)**: Ini adalah operasi standar. Perintah ini mengambil data dan templat Anda dan menghasilkan file `.xlsx` yang fungsional, dengan mempertahankan semua gaya sel, formula, dan format.

*   **`html`**: Mode ini pertama-tama menggabungkan data, lalu mengonversi spreadsheet yang dihasilkan menjadi satu file HTML dengan tabel HTML. Mode ini sangat baik untuk disematkan di halaman web atau untuk pratinjau cepat di browser. Semua gaya sel (warna, border) diubah menjadi inline CSS.

*   **`pdf`**: Mode ini melakukan penggabungan data dan kemudian menggunakan mesin rendering **mPDF** untuk mengonversi spreadsheet menjadi PDF. Ini ideal untuk menghasilkan laporan yang dapat dicetak.
*   **Kewajiban**: Anda harus menjalankan `composer require mpdf/mpdf` terlebih dahulu.
*   **Catatan**: Konversi ini bekerja paling baik untuk tata letak laporan standar. Spreadsheet yang sangat lebar mungkin akan diskalakan agar sesuai dengan halaman, yang dapat memengaruhi keterbacaan.

Here is a visual representation of what the `report_template.xlsx` file would look like in a spreadsheet application like Excel or Google Sheets, followed by a breakdown of each key element.

### Visual Representation of the XLSX Template

Imagine you are looking at this in Microsoft Excel:

| | **A** | **B** | **C** | **D** |
| :--- | :--- | :--- | :--- | :--- |
| **1**| | <font size="5"><b>Monthly Sales Report</b></font> (Merged across B:D) | | |
| **2**| | | | |
| **3**| **Month:** | `${report_details.month_name}` | | |
| **4**| **Generated On:** | `${generation_date}` | | |
| **5**| | | | |
| **6**| <font style="background-color:#D3D3D3;"><b>#</b></font> | <font style="background-color:#D3D3D3;"><b>Product Name</b></font> | <font style="background-color:#D3D3D3;"><b>Units Sold</b></font> | <font style="background-color:#D3D3D3;"><b>Revenue</b></font> |
| **7**| `${foreach:sales_data}` | `${item.product_name}` | `${item.units_sold}` | `${item.revenue}` |
| **8**| | | | |
| **9**| | | <font style="background-color:#D3D3D3;"><b>TOTAL:</b></font> | <font style="background-color:#D3D3D3;"><b>${total_revenue}</b></font> |

---

### Breakdown of the Template Elements

#### 1. Simple Placeholders
-   **Cell B3 (`${report_details.month_name}`)**: This is a standard placeholder that uses **dot notation** to access a nested value in your JSON.
-   **Cell B4 (`${generation_date}`)**: This placeholder will be replaced by a top-level key in your JSON.
-   **Cell D9 (`${total_revenue}`)**: Another simple placeholder. Notice that you can apply formatting (like **bold** text and a grey background) directly to the cell in Excel, and this formatting will be preserved in the final output.

#### 2. The Loop Template Row (Row 7)
This is the most important part of the template. The entire row acts as a blueprint for the data in your array.

-   **Cell A7 (`${foreach:sales_data}`)**: This is the **loop trigger**.
-   The command searches for cells starting with `${foreach:...}` in Column A.
-   `sales_data` is the key of the **array** in your JSON file.
-   This specific cell will be replaced by the item number (1, 2, 3, ...).
-   **Cell B7 (`${item.product_name}`)**: The `item.` prefix is special. It tells the command to look for the `product_name` key **inside an object within the `sales_data` array**.
-   **Cells C7 (`${item.units_sold}`) and D7 (`${item.revenue}`)**: These work the same way, accessing other keys from the array item.

#### 3. Formatting and Structure
-   **Row 6 (Headers)**: These are just static text cells. We've made them **bold** and given them a grey background color for clarity. This formatting is part of the template and will not be changed.
-   **Cell D7 (Revenue Placeholder)**: In Excel, you could format this cell as **Currency** (e.g., `$ #,##0.00`). When the command replaces `${item.revenue}` with a number like `7500`, Excel will automatically display it as `$ 7,500.00`. This formatting is copied for every new row created.
-   **Row 9 (Totals Row)**: This row exists *after* the loop template row. The `xlsx:generate` command is smart enough to insert the new rows for your loop data *before* this row, pushing it down automatically.

### How it Works During Generation

1.  The command loads this template.
2.  It finds `${foreach:sales_data}` in **A7**.
3.  It sees your JSON has 3 items in the `sales_data` array.
4.  It **inserts 2 new rows** below row 7. Now you have three identical "template" rows (rows 7, 8, and 9).
5.  It iterates through your array and populates these rows:
-   Row 7 is filled with data from the first item. `A7` becomes `1`, `B7` becomes `Widget Pro`, etc.
-   Row 8 is filled with data from the second item. `A8` becomes `2`, `B8` becomes `Gadget Plus`, etc.
-   Row 9 is filled with data from the third item.
6.  The "TOTAL" row, which was originally at row 9, is now at **row 11**, and all other simple placeholders (like `${report_details.month_name}`) are filled in.

The final output is a clean, formatted spreadsheet with a dynamically sized table.
